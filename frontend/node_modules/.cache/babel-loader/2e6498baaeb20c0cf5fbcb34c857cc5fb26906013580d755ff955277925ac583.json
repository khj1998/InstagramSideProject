{"ast":null,"code":"'use strict';\n\nvar has = Object.prototype.hasOwnProperty,\n  undef;\n\n/**\r\n * Decode a URI encoded string.\r\n *\r\n * @param {String} input The URI encoded string.\r\n * @returns {String|Null} The decoded string.\r\n * @api private\r\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\r\n * Attempts to encode a given input.\r\n *\r\n * @param {String} input The string that needs to be encoded.\r\n * @returns {String|Null} The encoded string.\r\n * @api private\r\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\r\n * Simple query string parser.\r\n *\r\n * @param {String} query The query string that needs to be parsed.\r\n * @returns {Object}\r\n * @api public\r\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g,\n    result = {},\n    part;\n  while (part = parser.exec(query)) {\n    var key = decode(part[1]),\n      value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n  return result;\n}\n\n/**\r\n * Transform a query string to an object.\r\n *\r\n * @param {Object} obj Object that should be transformed.\r\n * @param {String} prefix Optional prefix.\r\n * @returns {String}\r\n * @api public\r\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n  var pairs = [],\n    value,\n    key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key + '=' + value);\n    }\n  }\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;","map":{"version":3,"names":["has","Object","prototype","hasOwnProperty","undef","decode","input","decodeURIComponent","replace","e","encode","encodeURIComponent","querystring","query","parser","result","part","exec","key","value","querystringify","obj","prefix","pairs","call","isNaN","push","length","join","exports","stringify","parse"],"sources":["C:/코테이토5기 MSA스터디/InstagramClone/frontend/node_modules/querystringify/index.js"],"sourcesContent":["'use strict';\r\n\r\nvar has = Object.prototype.hasOwnProperty\r\n  , undef;\r\n\r\n/**\r\n * Decode a URI encoded string.\r\n *\r\n * @param {String} input The URI encoded string.\r\n * @returns {String|Null} The decoded string.\r\n * @api private\r\n */\r\nfunction decode(input) {\r\n  try {\r\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Attempts to encode a given input.\r\n *\r\n * @param {String} input The string that needs to be encoded.\r\n * @returns {String|Null} The encoded string.\r\n * @api private\r\n */\r\nfunction encode(input) {\r\n  try {\r\n    return encodeURIComponent(input);\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Simple query string parser.\r\n *\r\n * @param {String} query The query string that needs to be parsed.\r\n * @returns {Object}\r\n * @api public\r\n */\r\nfunction querystring(query) {\r\n  var parser = /([^=?#&]+)=?([^&]*)/g\r\n    , result = {}\r\n    , part;\r\n\r\n  while (part = parser.exec(query)) {\r\n    var key = decode(part[1])\r\n      , value = decode(part[2]);\r\n\r\n    //\r\n    // Prevent overriding of existing properties. This ensures that build-in\r\n    // methods like `toString` or __proto__ are not overriden by malicious\r\n    // querystrings.\r\n    //\r\n    // In the case if failed decoding, we want to omit the key/value pairs\r\n    // from the result.\r\n    //\r\n    if (key === null || value === null || key in result) continue;\r\n    result[key] = value;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Transform a query string to an object.\r\n *\r\n * @param {Object} obj Object that should be transformed.\r\n * @param {String} prefix Optional prefix.\r\n * @returns {String}\r\n * @api public\r\n */\r\nfunction querystringify(obj, prefix) {\r\n  prefix = prefix || '';\r\n\r\n  var pairs = []\r\n    , value\r\n    , key;\r\n\r\n  //\r\n  // Optionally prefix with a '?' if needed\r\n  //\r\n  if ('string' !== typeof prefix) prefix = '?';\r\n\r\n  for (key in obj) {\r\n    if (has.call(obj, key)) {\r\n      value = obj[key];\r\n\r\n      //\r\n      // Edge cases where we actually want to encode the value to an empty\r\n      // string instead of the stringified value.\r\n      //\r\n      if (!value && (value === null || value === undef || isNaN(value))) {\r\n        value = '';\r\n      }\r\n\r\n      key = encode(key);\r\n      value = encode(value);\r\n\r\n      //\r\n      // If we failed to encode the strings, we should bail out as we don't\r\n      // want to add invalid strings to the query.\r\n      //\r\n      if (key === null || value === null) continue;\r\n      pairs.push(key +'='+ value);\r\n    }\r\n  }\r\n\r\n  return pairs.length ? prefix + pairs.join('&') : '';\r\n}\r\n\r\n//\r\n// Expose the module.\r\n//\r\nexports.stringify = querystringify;\r\nexports.parse = querystring;\r\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,GAAG,GAAGC,MAAM,CAACC,SAAS,CAACC,cAAc;EACrCC,KAAK;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAM,CAACC,KAAK,EAAE;EACrB,IAAI;IACF,OAAOC,kBAAkB,CAACD,KAAK,CAACE,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;EACtD,CAAC,CAAC,OAAOC,CAAC,EAAE;IACV,OAAO,IAAI;EACb;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAM,CAACJ,KAAK,EAAE;EACrB,IAAI;IACF,OAAOK,kBAAkB,CAACL,KAAK,CAAC;EAClC,CAAC,CAAC,OAAOG,CAAC,EAAE;IACV,OAAO,IAAI;EACb;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,WAAW,CAACC,KAAK,EAAE;EAC1B,IAAIC,MAAM,GAAG,sBAAsB;IAC/BC,MAAM,GAAG,CAAC,CAAC;IACXC,IAAI;EAER,OAAOA,IAAI,GAAGF,MAAM,CAACG,IAAI,CAACJ,KAAK,CAAC,EAAE;IAChC,IAAIK,GAAG,GAAGb,MAAM,CAACW,IAAI,CAAC,CAAC,CAAC,CAAC;MACrBG,KAAK,GAAGd,MAAM,CAACW,IAAI,CAAC,CAAC,CAAC,CAAC;;IAE3B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIE,GAAG,KAAK,IAAI,IAAIC,KAAK,KAAK,IAAI,IAAID,GAAG,IAAIH,MAAM,EAAE;IACrDA,MAAM,CAACG,GAAG,CAAC,GAAGC,KAAK;EACrB;EAEA,OAAOJ,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,cAAc,CAACC,GAAG,EAAEC,MAAM,EAAE;EACnCA,MAAM,GAAGA,MAAM,IAAI,EAAE;EAErB,IAAIC,KAAK,GAAG,EAAE;IACVJ,KAAK;IACLD,GAAG;;EAEP;EACA;EACA;EACA,IAAI,QAAQ,KAAK,OAAOI,MAAM,EAAEA,MAAM,GAAG,GAAG;EAE5C,KAAKJ,GAAG,IAAIG,GAAG,EAAE;IACf,IAAIrB,GAAG,CAACwB,IAAI,CAACH,GAAG,EAAEH,GAAG,CAAC,EAAE;MACtBC,KAAK,GAAGE,GAAG,CAACH,GAAG,CAAC;;MAEhB;MACA;MACA;MACA;MACA,IAAI,CAACC,KAAK,KAAKA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKf,KAAK,IAAIqB,KAAK,CAACN,KAAK,CAAC,CAAC,EAAE;QACjEA,KAAK,GAAG,EAAE;MACZ;MAEAD,GAAG,GAAGR,MAAM,CAACQ,GAAG,CAAC;MACjBC,KAAK,GAAGT,MAAM,CAACS,KAAK,CAAC;;MAErB;MACA;MACA;MACA;MACA,IAAID,GAAG,KAAK,IAAI,IAAIC,KAAK,KAAK,IAAI,EAAE;MACpCI,KAAK,CAACG,IAAI,CAACR,GAAG,GAAE,GAAG,GAAEC,KAAK,CAAC;IAC7B;EACF;EAEA,OAAOI,KAAK,CAACI,MAAM,GAAGL,MAAM,GAAGC,KAAK,CAACK,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE;AACrD;;AAEA;AACA;AACA;AACAC,OAAO,CAACC,SAAS,GAAGV,cAAc;AAClCS,OAAO,CAACE,KAAK,GAAGnB,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}